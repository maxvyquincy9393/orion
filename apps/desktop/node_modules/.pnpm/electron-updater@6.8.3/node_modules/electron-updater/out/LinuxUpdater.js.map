{"version":3,"file":"LinuxUpdater.js","sourceRoot":"","sources":["../src/LinuxUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import { AllPublishOptions } from \"builder-util-runtime\"\nimport { AppAdapter } from \"./AppAdapter\"\nimport { BaseUpdater } from \"./BaseUpdater\"\n\nexport abstract class LinuxUpdater extends BaseUpdater {\n  constructor(options?: AllPublishOptions | null, app?: AppAdapter) {\n    super(options, app)\n  }\n\n  /**\n   * Returns true if the current process is running as root.\n   */\n  protected isRunningAsRoot(): boolean {\n    return process.getuid?.() === 0\n  }\n\n  /**\n   * Sanitizies the installer path for using with command line tools.\n   */\n  protected get installerPath(): string | null {\n    return super.installerPath?.replace(/\\\\/g, \"\\\\\\\\\").replace(/ /g, \"\\\\ \") ?? null\n  }\n\n  protected runCommandWithSudoIfNeeded(commandWithArgs: string[]) {\n    if (this.isRunningAsRoot()) {\n      this._logger.info(\"Running as root, no need to use sudo\")\n      return this.spawnSyncLog(commandWithArgs[0], commandWithArgs.slice(1))\n    }\n\n    const { name } = this.app\n    const installComment = `\"${name} would like to update\"`\n    const sudo = this.sudoWithArgs(installComment)\n    this._logger.info(`Running as non-root user, using sudo to install: ${sudo}`)\n    let wrapper = `\"`\n    // some sudo commands dont want the command to be wrapped in \" quotes\n    if (/pkexec/i.test(sudo[0]) || sudo[0] === \"sudo\") {\n      wrapper = \"\"\n    }\n    return this.spawnSyncLog(sudo[0], [...(sudo.length > 1 ? sudo.slice(1) : []), `${wrapper}/bin/bash`, \"-c\", `'${commandWithArgs.join(\" \")}'${wrapper}`])\n  }\n\n  protected sudoWithArgs(installComment: string): string[] {\n    const sudo = this.determineSudoCommand()\n    const command = [sudo]\n    if (/kdesudo/i.test(sudo)) {\n      command.push(\"--comment\", installComment)\n      command.push(\"-c\")\n    } else if (/gksudo/i.test(sudo)) {\n      command.push(\"--message\", installComment)\n    } else if (/pkexec/i.test(sudo)) {\n      command.push(\"--disable-internal-agent\")\n    }\n    return command\n  }\n\n  protected hasCommand(cmd: string): boolean {\n    try {\n      this.spawnSyncLog(`command`, [\"-v\", cmd])\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  protected determineSudoCommand(): string {\n    const sudos = [\"gksudo\", \"kdesudo\", \"pkexec\", \"beesu\"]\n    for (const sudo of sudos) {\n      if (this.hasCommand(sudo)) {\n        return sudo\n      }\n    }\n    return \"sudo\"\n  }\n\n  /**\n   * Detects the package manager to use based on the available commands.\n   * Allows overriding the default behavior by setting the ELECTRON_BUILDER_LINUX_PACKAGE_MANAGER environment variable.\n   * If the environment variable is set, it will be used directly. (This is useful for testing each package manager logic path.)\n   * Otherwise, it checks for the presence of the specified package manager commands in the order provided.\n   * @param pms - An array of package manager commands to check for, in priority order.\n   * @returns The detected package manager command or \"unknown\" if none are found.\n   */\n  protected detectPackageManager(pms: string[]): string {\n    const pmOverride = process.env.ELECTRON_BUILDER_LINUX_PACKAGE_MANAGER?.trim()\n    if (pmOverride) {\n      return pmOverride\n    }\n    // Check for the package manager in the order of priority\n    for (const pm of pms) {\n      if (this.hasCommand(pm)) {\n        return pm\n      }\n    }\n    // return the first package manager in the list if none are found, this will throw upstream for proper logging\n    this._logger.warn(`No package manager found in the list: ${pms.join(\", \")}. Defaulting to the first one: ${pms[0]}`)\n    return pms[0]\n  }\n}\n"]}