"""
models.py

SQLAlchemy ORM models for the Orion database.
Defines the schema for users, messages, sessions, memories, threads,
compressed memories, and trigger logs stored in PostgreSQL.

Models:
    User        — system user with preferences and metadata
    Message     — single chat message with role enum and session reference
    Session     — conversation session grouping messages together
    Memory      — key-value long-term memory entries with importance scoring
    Thread      — stateful conversation thread (open / waiting / resolved)
    CompressedMemory — LLM-generated summaries of old sessions
    TriggerLog  — audit log for proactive trigger events

Part of Orion — Persistent AI Companion System.
"""

from __future__ import annotations

import enum
import uuid
from datetime import datetime, timezone
from typing import Any

from sqlalchemy import (
    Boolean,
    Column,
    DateTime,
    Enum,
    Float,
    ForeignKey,
    Index,
    Integer,
    JSON,
    String,
    Text,
    create_engine,
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import DeclarativeBase, Mapped, relationship, Session as SASession

import config


# ---------------------------------------------------------------------------
# Declarative base
# ---------------------------------------------------------------------------

class Base(DeclarativeBase):
    """Shared declarative base for all Orion ORM models."""
    pass


# ---------------------------------------------------------------------------
# Enum types
# ---------------------------------------------------------------------------

class MessageRole(str, enum.Enum):
    """
    Allowed roles for a chat message.

    Values:
        USER: message from the human user
        ASSISTANT: message generated by Orion
        SYSTEM: system-level instruction or context injection
    """

    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"


class ThreadState(str, enum.Enum):
    """
    Lifecycle states for a conversation thread.

    Values:
        OPEN: actively being worked on
        WAITING: waiting for user reply or external event
        RESOLVED: completed and closed
    """

    OPEN = "open"
    WAITING = "waiting"
    RESOLVED = "resolved"


# ---------------------------------------------------------------------------
# Helper
# ---------------------------------------------------------------------------

def _utcnow() -> datetime:
    """Return the current UTC datetime (timezone-aware)."""
    return datetime.now(timezone.utc)


def _new_uuid() -> uuid.UUID:
    """Generate a new random UUID4."""
    return uuid.uuid4()


# ===========================================================================
# User
# ===========================================================================

class User(Base):
    """
    Represents a user in the Orion system.

    Attributes:
        id: UUID primary key.
        name: Display name.
        created_at: When the user record was created (UTC).
        preferences: Free-form JSON (theme, default engine, etc.).
        metadata_: Extra metadata stored as JSON.
    """

    __tablename__ = "users"

    id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), primary_key=True, default=_new_uuid
    )
    name: Mapped[str] = Column(String(255), nullable=False)
    created_at: Mapped[datetime] = Column(
        DateTime(timezone=True), default=_utcnow, nullable=False
    )
    preferences: Mapped[dict[str, Any]] = Column(JSON, default=dict, nullable=False)
    metadata_: Mapped[dict[str, Any]] = Column(
        "metadata", JSON, default=dict, nullable=False
    )

    # relationships
    messages: Mapped[list["Message"]] = relationship(
        "Message", back_populates="user", cascade="all, delete-orphan"
    )
    sessions: Mapped[list["Session"]] = relationship(
        "Session", back_populates="user", cascade="all, delete-orphan"
    )
    memories: Mapped[list["Memory"]] = relationship(
        "Memory", back_populates="user", cascade="all, delete-orphan"
    )
    threads: Mapped[list["Thread"]] = relationship(
        "Thread", back_populates="user", cascade="all, delete-orphan"
    )
    compressed_memories: Mapped[list["CompressedMemory"]] = relationship(
        "CompressedMemory", back_populates="user", cascade="all, delete-orphan"
    )
    trigger_logs: Mapped[list["TriggerLog"]] = relationship(
        "TriggerLog", back_populates="user", cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<User id={self.id!s} name={self.name!r}>"


# ===========================================================================
# Message
# ===========================================================================

class Message(Base):
    """
    A single chat message stored permanently for cross-session memory.

    Attributes:
        id: UUID primary key.
        user_id: FK to users.
        role: One of user / assistant / system (MessageRole enum).
        content: Full message text.
        timestamp: When the message was created (UTC).
        session_id: FK to sessions (nullable — legacy messages may lack this).
        thread_id: FK to threads (nullable).
        metadata_: Additional JSON (engine used, token count, etc.).
    """

    __tablename__ = "messages"

    id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), primary_key=True, default=_new_uuid
    )
    user_id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False
    )
    role: Mapped[MessageRole] = Column(
        Enum(MessageRole, name="message_role", create_constraint=True),
        nullable=False,
    )
    content: Mapped[str] = Column(Text, nullable=False)
    timestamp: Mapped[datetime] = Column(
        DateTime(timezone=True), default=_utcnow, nullable=False, index=True
    )
    session_id: Mapped[uuid.UUID | None] = Column(
        UUID(as_uuid=True),
        ForeignKey("sessions.id", ondelete="SET NULL"),
        nullable=True,
    )
    thread_id: Mapped[uuid.UUID | None] = Column(
        UUID(as_uuid=True),
        ForeignKey("threads.id", ondelete="SET NULL"),
        nullable=True,
    )
    metadata_: Mapped[dict[str, Any]] = Column(
        "metadata", JSON, default=dict, nullable=False
    )

    # relationships
    user: Mapped["User"] = relationship("User", back_populates="messages")
    session: Mapped["Session | None"] = relationship(
        "Session", back_populates="messages"
    )
    thread: Mapped["Thread | None"] = relationship(
        "Thread", back_populates="messages"
    )

    # DECISION: Composite index on (user_id, timestamp) for efficient history queries
    # WHY: get_history() always filters by user and orders by timestamp
    __table_args__ = (
        Index("ix_messages_user_timestamp", "user_id", "timestamp"),
    )

    def __repr__(self) -> str:
        return (
            f"<Message id={self.id!s} role={self.role.value!r} "
            f"user_id={self.user_id!s}>"
        )


# ===========================================================================
# Session
# ===========================================================================

class Session(Base):
    """
    Groups messages into logical conversation sessions.
    When a session is compressed, its summary is stored in CompressedMemory
    and old messages may be pruned.

    Attributes:
        id: UUID primary key.
        user_id: FK to users.
        started_at: Session start time (UTC).
        ended_at: Session end time (nullable — None while active).
        summary: LLM-generated summary after compression (nullable).
        message_count: Running count of messages in this session.
    """

    __tablename__ = "sessions"

    id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), primary_key=True, default=_new_uuid
    )
    user_id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False
    )
    started_at: Mapped[datetime] = Column(
        DateTime(timezone=True), default=_utcnow, nullable=False
    )
    ended_at: Mapped[datetime | None] = Column(
        DateTime(timezone=True), nullable=True
    )
    summary: Mapped[str | None] = Column(Text, nullable=True)
    message_count: Mapped[int] = Column(Integer, default=0, nullable=False)

    # relationships
    user: Mapped["User"] = relationship("User", back_populates="sessions")
    messages: Mapped[list["Message"]] = relationship(
        "Message", back_populates="session"
    )

    __table_args__ = (
        Index("ix_sessions_user_started", "user_id", "started_at"),
    )

    def __repr__(self) -> str:
        return (
            f"<Session id={self.id!s} user_id={self.user_id!s} "
            f"msgs={self.message_count}>"
        )


# ===========================================================================
# Memory  (key-value long-term store)
# ===========================================================================

class Memory(Base):
    """
    Key-value long-term memory entries with importance scoring.
    Used by the memory system for facts, preferences, and user context
    that should persist indefinitely.

    Attributes:
        id: UUID primary key.
        user_id: FK to users.
        key: Topic / label (e.g. "favorite_language", "birthday").
        value: The stored information as text.
        importance: Float 0.0–1.0 indicating retrieval priority.
        created_at: When this memory was first created (UTC).
        last_accessed: Last time this memory was retrieved (UTC).
        access_count: How many times this memory was read.
    """

    __tablename__ = "memories"

    id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), primary_key=True, default=_new_uuid
    )
    user_id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False
    )
    key: Mapped[str] = Column(String(255), nullable=False)
    value: Mapped[str] = Column(Text, nullable=False)
    importance: Mapped[float] = Column(Float, default=0.5, nullable=False)
    created_at: Mapped[datetime] = Column(
        DateTime(timezone=True), default=_utcnow, nullable=False
    )
    last_accessed: Mapped[datetime] = Column(
        DateTime(timezone=True), default=_utcnow, nullable=False
    )
    access_count: Mapped[int] = Column(Integer, default=0, nullable=False)

    # relationships
    user: Mapped["User"] = relationship("User", back_populates="memories")

    __table_args__ = (
        Index("ix_memories_user_key", "user_id", "key"),
        Index("ix_memories_importance", "importance"),
    )

    def __repr__(self) -> str:
        return (
            f"<Memory id={self.id!s} key={self.key!r} "
            f"importance={self.importance:.2f}>"
        )


# ===========================================================================
# Thread
# ===========================================================================

class Thread(Base):
    """
    A stateful conversation thread.
    Tracks lifecycle: open → waiting → resolved.

    Attributes:
        id: UUID primary key.
        user_id: FK to users.
        trigger: What initiated this thread (e.g. "proactive_reminder").
        state: Current lifecycle state (ThreadState enum).
        created_at: Thread creation time (UTC).
        updated_at: Last state change (UTC, auto-updated on modification).
        context: Arbitrary JSON blob for thread-specific context.
    """

    __tablename__ = "threads"

    id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), primary_key=True, default=_new_uuid
    )
    user_id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False
    )
    trigger: Mapped[str] = Column(String(255), nullable=False)
    state: Mapped[ThreadState] = Column(
        Enum(ThreadState, name="thread_state", create_constraint=True),
        default=ThreadState.OPEN,
        nullable=False,
    )
    created_at: Mapped[datetime] = Column(
        DateTime(timezone=True), default=_utcnow, nullable=False
    )
    updated_at: Mapped[datetime] = Column(
        DateTime(timezone=True), default=_utcnow, onupdate=_utcnow, nullable=False
    )
    context: Mapped[dict[str, Any]] = Column(JSON, default=dict, nullable=False)

    # relationships
    user: Mapped["User"] = relationship("User", back_populates="threads")
    messages: Mapped[list["Message"]] = relationship(
        "Message", back_populates="thread"
    )

    __table_args__ = (
        Index("ix_threads_user_state", "user_id", "state"),
    )

    def __repr__(self) -> str:
        return (
            f"<Thread id={self.id!s} trigger={self.trigger!r} "
            f"state={self.state.value!r}>"
        )


# ===========================================================================
# CompressedMemory
# ===========================================================================

class CompressedMemory(Base):
    """
    Stores LLM-generated summaries of old conversation sessions.
    Used for long-term memory retrieval without keeping every raw message.

    Attributes:
        id: UUID primary key.
        user_id: FK to users.
        session_id: FK to the session that was compressed (nullable for legacy).
        summary: The compressed summary text.
        original_message_count: How many messages were summarised.
        date_range_start: Earliest message timestamp in the compressed range.
        date_range_end: Latest message timestamp in the compressed range.
        created_at: When the compression was performed (UTC).
    """

    __tablename__ = "compressed_memories"

    id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), primary_key=True, default=_new_uuid
    )
    user_id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False
    )
    session_id: Mapped[uuid.UUID | None] = Column(
        UUID(as_uuid=True),
        ForeignKey("sessions.id", ondelete="SET NULL"),
        nullable=True,
    )
    summary: Mapped[str] = Column(Text, nullable=False)
    original_message_count: Mapped[int] = Column(Integer, nullable=False)
    date_range_start: Mapped[datetime] = Column(
        DateTime(timezone=True), nullable=False
    )
    date_range_end: Mapped[datetime] = Column(
        DateTime(timezone=True), nullable=False
    )
    created_at: Mapped[datetime] = Column(
        DateTime(timezone=True), default=_utcnow, nullable=False
    )

    # relationships
    user: Mapped["User"] = relationship("User", back_populates="compressed_memories")
    session: Mapped["Session | None"] = relationship("Session")

    __table_args__ = (
        Index("ix_compressed_user_date", "user_id", "date_range_start"),
    )

    def __repr__(self) -> str:
        return (
            f"<CompressedMemory id={self.id!s} user_id={self.user_id!s} "
            f"msgs={self.original_message_count}>"
        )


# ===========================================================================
# TriggerLog
# ===========================================================================

class TriggerLog(Base):
    """
    Audit log for proactive trigger events.
    Records every time the background process decided (or declined)
    to reach out to the user.

    Attributes:
        id: UUID primary key.
        user_id: FK to users.
        trigger_type: Category of the trigger (e.g. "reminder", "anomaly").
        reason: Human-readable explanation of why the trigger fired.
        urgency: Priority tag — low / medium / high / critical.
        acted_on: Whether Orion actually delivered a message for this trigger.
        created_at: When the trigger event occurred (UTC).
    """

    __tablename__ = "trigger_logs"

    id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), primary_key=True, default=_new_uuid
    )
    user_id: Mapped[uuid.UUID] = Column(
        UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False
    )
    trigger_type: Mapped[str] = Column(String(100), nullable=False)
    reason: Mapped[str] = Column(Text, nullable=False)
    urgency: Mapped[str] = Column(String(20), default="medium", nullable=False)
    acted_on: Mapped[bool] = Column(Boolean, default=False, nullable=False)
    created_at: Mapped[datetime] = Column(
        DateTime(timezone=True), default=_utcnow, nullable=False
    )

    # relationships
    user: Mapped["User"] = relationship("User", back_populates="trigger_logs")

    __table_args__ = (
        Index("ix_trigger_logs_user_created", "user_id", "created_at"),
    )

    def __repr__(self) -> str:
        return (
            f"<TriggerLog id={self.id!s} type={self.trigger_type!r} "
            f"urgency={self.urgency!r}>"
        )


# ===========================================================================
# Engine / Session helpers
# ===========================================================================

_engine = None


def get_engine():
    """
    Return the global SQLAlchemy engine, creating it lazily from config.DATABASE_URL.

    Returns:
        sqlalchemy.engine.Engine: The database engine instance.

    Example:
        engine = get_engine()
    """
    global _engine
    if _engine is None:
        _engine = create_engine(
            config.DATABASE_URL,
            pool_pre_ping=True,
            echo=(config.LOG_LEVEL == "DEBUG"),
        )
    return _engine


def get_session() -> SASession:
    """
    Create and return a new SQLAlchemy session bound to the global engine.
    Callers are responsible for committing / closing.

    Returns:
        sqlalchemy.orm.Session: A new ORM session.

    Example:
        with get_session() as session:
            session.add(user)
            session.commit()
    """
    return SASession(bind=get_engine())


def create_all_tables() -> None:
    """
    Create all tables defined by the ORM models.
    Safe to call multiple times — skips tables that already exist.

    Example:
        create_all_tables()
    """
    Base.metadata.create_all(bind=get_engine())


def drop_all_tables() -> None:
    """
    Drop ALL tables defined by the ORM models.
    **Destructive** — use only in tests or during a full reset.

    Example:
        drop_all_tables()  # deletes everything!
    """
    Base.metadata.drop_all(bind=get_engine())
